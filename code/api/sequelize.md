# Sequelize

A Javascript based Object Relational Mapper (ORM) for tracking the relationship between a database schema and data objects used in software. (e.g. JSON representation)

https://sequelize.org/  
Sequelize ORM  
https://sequelize.org/master/  
Manual | Sequelize  
https://github.com/sequelize/sequelize/  
sequelize/sequelize: An easy-to-use multi SQL dialect ORM tool for Node.js  
https://sequelize.org/master/manual/model-basics.html#numbers  
Manual | Sequelize  
https://sequelize.org/master/manual/migrations.html  
Manual | Sequelize  
  
https://github.com/feathersjs-ecosystem/feathers-sequelize  

## Schema Generation

Sequelize Auto can help generate schemas from an existing database

https://github.com/sequelize/sequelize-auto  
sequelize/sequelize-auto: Automatically generate bare sequelize models from your database.  
  
TODO - document how to incorporate these in with an API  
fully automated vs grouping associations in with the model file  

TODO - Output should be closer to the Feather's model definition approach  
Include the associations in with the model  


## Migrations

Migrations help your database schema stay up-to-date with the demands of the current system architecture. 

If nothing else, just use a file to track the SQL commands that get applied

You'll want to use SQL commands to `ALTER` tables

[relational databases](relational-db.md)


Great documentation:

https://eddyystop.gitbooks.io/feathers-docs-common/content/databases/sequelize.html#migrations

Having trouble locating the repo. 

[Sequelize · feathers-docs-common](https://eddyystop.gitbooks.io/feathers-docs-common/content/databases/sequelize.html#migrations)

The following assumes you have a `migrations` folder in the root of your app.


### Initial Setup: one-time tasks
 
  -   Install the [sequelize CLI](https://github.com/sequelize/cli):
 
      npm install sequelize-cli --save
 
  -   Create a `.sequelizerc` file in your project root with the following content:
 
```
const path = require('path');

module.exports = {
  'config': path.resolve('migrations/config/config.js'),
  'migrations-path': path.resolve('migrations'),
  'seeders-path': path.resolve('migrations/seeders'),
  'models-path': path.resolve('migrations/models')
};
```
 
  -   Create the migrations config in `migrations/config/config.js`:
 
```
const app = require('../../src/app');
const env = process.env.NODE_ENV || 'development';

module.exports = {
  [env]: {
    url: app.get('db_url'),
    dialect: app.get('db_dialect'),
    migrationStorageTableName: '_migrations'
  }
};
```

  -   Register your models. The following assumes you have defined your models using the method [described here](https://github.com/feathersjs/generator-feathers/issues/94#issuecomment-204165134).

```
const Sequelize = require('sequelize');
const app = require('../../src/app');
const models = app.get('models');
const sequelize = app.get('sequelize');
     
// The export object must be a dictionary of model names -> models
// It must also include sequelize (instance) and Sequelize (constructor) properties
module.exports = Object.assign({
  Sequelize,
  sequelize
}, models);
```

 * * *
 
### Migrations workflow
 
The migration commands will load your application and it is therefore required that you define the same environment variables as when running you application. For example, many applications will define the database connection string in the startup command:
 
```
DATABASE_URL=postgres://user:pass@host:port/dbname npm start
```

All of the following commands assume that you have defined the same environment variables used by your application.
 
> **ProTip:** To save typing, you can export environment variables for your current bash/terminal session:
> 
>     export DATABASE_URL=postgres://user:pass@host:port/db
     
 
### Create a new migration
 
To create a new migration file, run the following command and provide a meaningful name:
 
     sequelize migration:create --name="meaningful-name"
     
This will create a new file in the migrations folder. All migration file names will be prefixed with a sortable data/time string: `20160421135254-meaninful-name.js`. This prefix is crucial for making sure your migrations are executed in the proper order.
 
> **NOTE:** The order of your migrations is determined by the alphabetical order of the migration scripts in the file system. The file names generated by the CLI tools will always ensure that the most recent migration comes last.


#### Add the up/down scripts:
 
Open the newly created migration file and write the code to both apply and undo the migration. Please refer to the [sequelize migration functions](http://docs.sequelizejs.com/en/latest/docs/migrations/#functions) for available operations. **Do not be lazy - write the down script too and test!** Here is an example of converting a `NOT NULL` column accept null values:

```
'use strict';
     
module.exports = {
  up: function (queryInterface, Sequelize) {
    return queryInterface.changeColumn('tableName', 'columnName', {
      type: Sequelize.STRING,
      allowNull: true
    });
  },
  
  down: function (queryInterface, Sequelize) {
    return queryInterface.changeColumn('tableName', 'columnName', {
      type: Sequelize.STRING,
      allowNull: false
    });
  }
};
```

 
> **ProTip:** As of this writing, if you use the `changeColumn` method you must **always** specify the `type`, even if the type is not changing.
> 
> **ProTip:** Down scripts are typically easy to create and should be nearly identical to the up script except with inverted logic and inverse method calls.

#### Keeping your app code in sync with migrations

The application code should always be up to date with the migrations. This allows the app to be freshly installed with everything up-to-date without running the migration scripts. Your migrations should also never break a freshly installed app. This often times requires that you perform any necessary checks before executing a task. For example, if you update a model to include a new field, your migration should first check to make sure that new field does not exist:


```
'use strict';
 
module.exports = {
  up: function (queryInterface, Sequelize) {
    return queryInterface.describeTable('tableName').then(attributes => {
      if ( !attributes.columnName ) {
        return queryInterface.addColumn('tableName', 'columnName', {
          type: Sequelize.INTEGER,
          defaultValue: 0
        });
      }
    })
  },

  down: function (queryInterface, Sequelize) {
    return queryInterface.describeTable('tableName').then(attributes => {
      if ( attributes.columnName ) {
        return queryInterface.removeColumn('tableName', 'columnName');
      }
    });
  }
};
````


### Apply a migration

The CLI tools will always run your migrations in the correct order and will keep track of which migrations have been applied and which have not. This data is stored in the database under the `_migrations` table. To ensure you are up to date, simply run the following:

    sequelize db:migrate
    

> **ProTip:** You can add the migrations script to your application startup command to ensure that all migrations have run every time your app is started. Try updating your package.json `scripts` attribute and run `npm start`:
> 
>     scripts: {
>         start: "sequelize db:migrate && node src/"
>     }
>     

### Undo the previous migration

To undo the last migration, run the following command:

    sequelize db:migrate:undo
    

Continue running the command to undo each migration one at a time - the migrations will be undone in the proper order.

> **Note:** - You shouldn't really have to undo a migration unless you are the one developing a new migration and you want to test that it works. Applications rarely have to revert to a previous state, but when they do you will be glad you took the time to write and test your `down` scripts!

### Reverting your app to a previous state

In the unfortunate case where you must revert your app to a previous state, it is important to take your time and plan your method of attack. Every application is different and there is no one-size-fits-all strategy for rewinding an application. However, most applications should be able to follow these steps (order is important):

1.  Stop your application (kill the process)
2.  Find the last stable version of your app
3.  Count the number of migrations which have been added since that version
4.  Undo your migrations one at a time until the db is in the correct state
5.  Revert your code back to the previous state
6.  Start your app




## Queries

https://sequelize.org/master/manual/model-querying-basics.html

TODO - Seems very similar to mongo API. How does it compare? 

### Select

```
Model.findAll({
  attributes: ['foo', 'bar']
});
```

### Insert

```
const jane = await User.create({ firstName: "Jane", lastName: "Doe" });
console.log("Jane's auto-generated ID:", jane.id);
```


## API Integration

TODO - expand to include all actions that a feathers server provides by default
TODO - 'update' via 'PATCH'

```
var express = require("express");
var router = express.Router();
var db = require("../db");
const { Op } = require("sequelize");

/* GET the associated records of a project */
router.get("/:id", function (req, res, next) {
	db.project
		.findOne({
			where: { _id: req.params.id },
			include: [
				{
					model: db.sample,
					as: "samples",
					include: [
						{ model: db.datafile, as: "files" },
						{ model: db.source, as: "source" },
					],
				},
				{ model: db.datafile, as: "files" },
			],
		})
		.then((match) => {
			res.json(match);
		});
});

router.delete("/:id", function (req, res, next) {
	db.project
		.destroy({
			where: { _id: req.params.id },
		})
		.then((match) => {
			res.json({ result: "success" });
		})
		.catch((err) => {
			next(err);
		});
});

router.get("/", function (req, res, next) {
	db.project
		.findAll({
			include: [
				// { model: users, attributes: ["email"] },
				{
					model: db.sample,
					as: "samples",
					include: [
						{ model: db.datafile, as: "files" },
						{ model: db.source, as: "source" },
					],
				},
				{ model: db.datafile, as: "files" },

				{ model: db.investigator, as: "investigators" },
			],
		})
		.then((matches) => {
			res.json(matches);
		});
});

router.post("/", function (req, res, next) {
	// const newProject = JSON.parse(req.body);
	// console.log("CREATE NEW PROJECT", req.body);
	db.project
		.create(req.body)
		.then((created) => {
			res.json(created);
		})
		.catch((err) => {
			next(err);
		});
});

module.exports = router;

```


## Relations / Associations

Many of these can be defined automatically by generating the models from the database. (See Above)

With sequelize the behavior of populating a related object is called `include`.

http://docs.sequelizejs.com/en/latest/docs/associations/

In Feathers, associations are defined on the Models. These will then be initialized by sequelize via `api/src/sequelize.js`. 

Make use of "references" parameter to indicate the parent relationship, e.g.

```
    project_id: {
      type: DataTypes.STRING(255),
      allowNull: true,
      references: {
        model: 'research_project',
        key: 'project_id'
      }
    },

```

On both related models define the associations:

```
  project.associate = function (models) {
    // Define associations here
    // See http://docs.sequelizejs.com/en/latest/docs/associations/
    project.hasMany(models.datafile, {
      as: "files",
      foreignKey: "project_id",
    });

```

Depending on the association type, the foreignKey property may refer to the local object or the child object. 

`hasMany` will refer to a foreignKey on the child object
`belongsTo` will refer to a foreignKey on the local object




Then, when `find` or `get` is used to return results from the database, in Feathers it is important to create a hook that will `include` associated results. 

in `api/src/hooks/get-samples.js`

``` 
// eslint-disable-next-line no-unused-vars
module.exports = (options = {}) => {
  return async (context) => {
    const sequelize = context.app.get("sequelizeClient");
    const { sample } = sequelize.models;
    context.params.sequelize = {
      include: [
        // { model: users, attributes: ["email"] },
        { model: sample, as: "samples" },
      ],
      raw: false,
    };
    return context;
  };
};
```

This guide was helpful for using sequelize in Feathers JS
https://medium.com/@mohammedalrowad/feathersjs-association-hooks-with-sequelize-1825356b1843

### Many to Many

https://sequelize.org/master/manual/advanced-many-to-many.html

The trick was in initializing the through model

without creating a dedicated service for the through model
(although maybe that is desirable? ... can always add it in later)

I initialized manually in `api/src/sequelize.js` with:

``` 
const createThroughModel = require("./models/through.model.js");

module.exports = function (app) {

...

  app.setup = function (...args) {
    const result = oldSetup.apply(this, args);

    createThroughModel(app);
```

https://stackoverflow.com/questions/48602085/using-feathers-client-and-sequelize-many-to-many-relation

https://stackoverflow.com/questions/51827290/how-to-define-many-to-many-with-feathers-and-sequelize-with-additional-fields-in



## Legacy Database Schema

Sometimes it's necessary to work with an existing schema. Ideally, apply migrations as needed. 

It can be useful to assign different names to columns. Hint: use 'as' parameter

```
			include: [
				{
					model: db.example,
					as: "examples",
                    ...
                    
```

https://duckduckgo.com/?t=ffab&q=sequelize+specify+column+name&ia=web
sequelize specify column name at DuckDuckGo
https://stackoverflow.com/questions/55114922/change-column-name-sequilize
node.js - Change column name Sequilize - Stack Overflow
https://duckduckgo.com/?t=ffab&q=sequelize+specify+id&ia=web
sequelize specify id at DuckDuckGo
https://sequelize.org/master/manual/legacy.html
Manual | Sequelize
https://github.com/sequelize/sequelize/issues/741
Don't have a column call id column · Issue #741 · sequelize/sequelize

